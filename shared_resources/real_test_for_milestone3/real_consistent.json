["\ndef recv_pkt(self):\n    nmsglen = self._sock.recv(4)\n    if (len(nmsglen) != 4):\n            raise RiakError(\"Socket returned short packet length {0} - expected 4\".\n                            format(nmsglen))\n    msglen, = struct.unpack('!i', nmsglen)\n    self._inbuf_len = msglen\n    self._inbuf = ''\n    while len(self._inbuf) < msglen:\n            want_len = min(8192, msglen - len(self._inbuf))\n            recv_buf = self._sock.recv(want_len)\n            if len(recv_buf) != want_len:\n                    raise RiakError(\"Socket returned short read {0} - expected {1}\".\n                                    format(len(recv_buf), want_len))\n            self._inbuf += recv_buf\n", "\ndef handle_token(cls, parser, token):\n    bits = token.split_contents()\n\n    if len(bits) != 4 and len(bits) != 6:\n        raise template.TemplateSyntaxError(\"%r takes exactly three or six \"\n            \"arguments (second argument must be 'as')\" % str(bits[0]))\n    if bits[2] != \"as\":\n        raise template.TemplateSyntaxError(\"Second argument to %r must be \"\n            \"'as'\" % str(bits[0]))\n    if len(bits) == 6:\n        if bits[4] != \"limit\":\n            raise template.TemplateSyntaxError(\"Fourth argument to %r must be \"\n                \"'limit'\" % bits[0])\n        limit = bits[5]\n    else:\n        limit = None\n\n    return cls(bits[1], bits[3])\n", "\ndef post_full_clean(cls, user, obj):\n    if not obj.id == None:\n        raise ValueError('BUG: Students should only have create permission on Delivery')\n    obj.time_of_delivery = datetime.now()\n    obj.delivered_by = user\n    #obj.deadline = obj.assignment_group.get_active_deadline()\n", "\ndef __new__(cls, *args):\n    args = [_sympify(arg) for arg in args]\n    obj = Basic.__new__(cls, *args)\n    ranks = [get_rank(arg) for arg in args]\n    ranks = list(set(ranks))\n    if len(ranks) != 1:\n        raise ValueError(\"summing arrays of different ranks\")\n    obj._subranks = ranks\n    shapes = [arg.shape for arg in args]\n    if len(set([i for i in shapes if i is not None])) > 1:\n        raise ValueError(\"mismatching shapes in addition\")\n    if any(i is None for i in shapes):\n        obj._shape = None\n    else:\n        obj._shape = shapes[0]\n    return obj\n", "\ndef critical_angle(medium1, medium2):\n    n1, n2 = None, None\n    if isinstance(medium1, Medium):\n        n1 = medium1.refractive_index\n    else:\n        n1 = sympify(medium1)\n    if isinstance(medium2, Medium):\n        n2 = medium2.refractive_index\n    else:\n        n2 = sympify(medium2)\n\n    if n2 > n1:\n        raise ValueError('Total internal reflection impossible for n1 > n2')\n    else:\n        return asin(n2/n1)\n", "\ndef __new__(cls, arg1, arg2):\n    if not arg1.is_Matrix:\n        raise TypeError(\"Input to Dot Product, %s, not a matrix\" % str(arg1))\n    if not arg2.is_Matrix:\n        raise TypeError(\"Input to Dot Product, %s, not a matrix\" % str(arg2))\n    if not (1 in arg1.shape):\n        raise TypeError(\"Input to Dot Product, %s, not a vector\" % str(arg1))\n", "\ndef test_py_version():\n    from sys import version_info\n    if version_info < (3, 6):\n        raise NotImplementedError(\"Currently only Python versions >3.5 are supported!\")\n", "        \ndef test_download_gzip_response(self):\n        if twisted_version > (12, 3, 0):\n            crawler = get_crawler(SingleRequestSpider)\n            body = b'1'*100 # PayloadResource requires body length to be 100\n            request = Request('http://localhost:8998/payload', method='POST', body=body, meta={'download_maxsize': 50})\n            yield crawler.crawl(seed=request)\n            failure = crawler.spider.meta['failure']\n            # download_maxsize < 100, hence the CancelledError\n            self.assertIsInstance(failure.value, defer.CancelledError)\n\n            if six.PY2:\n                request.headers.setdefault(b'Accept-Encoding', b'gzip,deflate')\n                request = request.replace(url='http://localhost:8998/xpayload')\n                yield crawler.crawl(seed=request)\n                # download_maxsize = 50 is enough for the gzipped response\n                # See issue https://twistedmatrix.com/trac/ticket/8175\n                failure = crawler.spider.meta.get('failure')\n                self.assertTrue(failure == None)\n                reason = crawler.spider.meta['close_reason']\n                self.assertTrue(reason, 'finished')\n            else:\n                raise unittest.SkipTest(\"xpayload only enabled for PY2\")\n        else:\n            raise unittest.SkipTest(\"xpayload and payload endpoint only enabled for twisted > 12.3.0\")           \n", "\ndef __init__(self, body, valign=MIDDLE, height=PACK, min_height=None,\n            top=0, bottom=0):\n    self.__super.__init__(body)\n    # convert old parameters to the new top/bottom values\n    if isinstance(height, tuple):\n        if height[0] == 'fixed top':\n            if not isinstance(valign, tuple) or valign[0] != 'fixed bottom':\n                raise FillerError(\"fixed top height may only be used \"\n                    \"with fixed bottom valign\")\n            top = height[1]\n            height = RELATIVE_100\n        elif height[0] == 'fixed bottom':\n            if not isinstance(valign, tuple) or valign[0] != 'fixed top':\n                raise FillerError(\"fixed bottom height may only be used \"\n                    \"with fixed top valign\")\n            bottom = height[1]\n            height = RELATIVE_100\n    if isinstance(valign, tuple):\n        if valign[0] == 'fixed top':\n            top = valign[1]\n            valign = TOP\n        elif valign[0] == 'fixed bottom':\n            bottom = valign[1]\n            valign = BOTTOM\n", "\ndef send_email(self, source, subject, body, to_addresses, cc_addresses=None,\n                   bcc_addresses=None, format='text', reply_addresses=None,\n                   return_path=None, text_body=None, html_body=None):\n\n    format = format.lower().strip()\n    if body is not None:\n        if format == \"text\":\n            if text_body is not None:\n                raise Warning(\"You've passed in both a body and a text_body; please choose one or the other.\")\n            text_body = body\n        else:\n            if html_body is not None:\n                raise Warning(\"You've passed in both a body and an html_body; please choose one or the other.\")\n            html_body = body\n    params = {\n        'Source': source,\n        'Message.Subject.Data': subject,\n    }\n    if return_path:\n        params['ReturnPath'] = return_path\n    if html_body is not None:\n        params['Message.Body.Html.Data'] = html_body\n    if text_body is not None:\n        params['Message.Body.Text.Data'] = text_body\n    if(format not in (\"text\",\"html\")):\n        raise ValueError(\"'format' argument must be 'text' or 'html'\")\n\n    if(not (html_body or text_body)):\n        raise ValueError(\"No text or html body found for mail\")\n\n    self._build_list_params(params, to_addresses,\n                           'Destination.ToAddresses.member')\n    if cc_addresses:\n        self._build_list_params(params, cc_addresses,\n                               'Destination.CcAddresses.member')\n    if bcc_addresses:\n        self._build_list_params(params, bcc_addresses,\n                               'Destination.BccAddresses.member')\n    if reply_addresses:\n        self._build_list_params(params, reply_addresses,\n                               'ReplyToAddresses.member')\n    return self._make_request('SendEmail', params)\n"]